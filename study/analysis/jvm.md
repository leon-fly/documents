---
date: "2018-01-01"
draft: false
lastmod: "2018-01-01"
publishdate: "2018-01-01"
tags:
- analysis
title: jvm
---
# 关于JVM

一张图展示JVM核心部分

![jvm](../../picture/jvm.png)

## 运行时数据区

**程序计数器（PC寄存器）**

* 一块较小的内存空间，存放当前线程所执行的字节码的行号指示器
* 每个线程有自己独立的一个程序计数器，生命周期同属主线程
* 如果正在执行的是一个本地方法，这个计数器值则应为空



**虚拟机栈**

* 线程私有，生命周期同属主线程相同。
* 其描述的是java方法执行的线程内存模型。每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
* 一个虚拟机栈可以有多个栈帧
* 对于栈来说不存在GC问题，但存在内存溢出问题（OOM）



**本地方法栈**

存放本地方法调用过程中的栈帧。用于管理本地方法的调用，本地方法是C语言写的。不是所有虚拟机都支持本地方法栈，例如Hotspot虚拟机就是将本地方法栈和虚拟机栈合二为一。栈解决程序的运行问题，即程序如何执行、如何处理数据。



**方法区**

方法区可以看作是一块独立于Java堆的内存空间，方法区是各线程共享的内存区域。方法区是一个抽象概念，永久代和元空间是方法区的实现方式。

* 永久代

属于JVM方法区的内存，用来存储类的元数据，如类名、方法信息、字段信息等一些静态的数据。JDK7及之前方法区也叫永久代。缺点是内存大小固定，容易出现oom问题。可以通过-XX:PermSize设置永久代大小。永久代对象只能通过Major GC（又称Full GC）进行垃圾回收。

* 元空间

元空间是Hotspot在JDK8引入的，用于取代永久代。元空间属于本地内存，由操作系统直接管理，不再受JVM管理。同时内存空间可以自动扩容，避免内存溢出。默认情况下元空间可以无限使用本地内存，也可以通过-XX:MetaspaceSize限制内存大小。

* 常量池

常量池就是一张表，JVM根据这张常量表找到要执行的类信息和方法信息

​	**类常量池**：是.class字节码文件中的资源仓库，主要存放字面量（表示字符串值和数值，例如字符串值"abc"、final常量、静态变量）和符号引用（类和接口的全限定名、字段名、方法名）。

​	**运行时常量池**：类加载的“加载”阶段会创建运行时常量池，统一存放各个类常量池去重后的符号引用。在类加载的“解析”阶段JVM会把运行时常量池的这些符号引用转为直接引用。类常量池。类常量池在字节码文件中的，运行时常量池在内存中。

​	**字符串常量池**：专门针对String类型设计的常量池。是当前应用程序里所有线程共享的，每个jvm只有一个字符串常量池。存储字符串对象的引用。在创建String对象时，JVM会先在字符串常量池寻找是否已存在相同字符串的引用，如果有的话就直接返回引用，没的话就在堆中创建一个对象，然后常量池保存这个引用并返回引用。

**堆**

存放对象实例、实例变量、数组，包括新生代（伊甸园区、幸存区S0和S1）和老年代。堆是垃圾收集器管理的内存区域。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。堆实际内存空间可以不连续，大小可以选择固定大小或可扩展，堆是各线程共享的内存区域。

## 执行引擎

将字节码指令解释/编译为对应平台上的本地机器指令。充当了将高级语言翻译为机器语言的译者。执行引擎在执行过程中需要执行什么样的字节码指令依赖于PC寄存器。每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。

字节码指令（JVM指令）：字节码文件中的指令，内部只包含一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息，不能够直接运行在操作系统之上。

本地机器指令：可以直接运行在操作系统之上。



### 参考

周志明《深入理解java虚拟机》

[深入解析JVM之虚拟机栈 - 知乎](https://zhuanlan.zhihu.com/p/423364303)
