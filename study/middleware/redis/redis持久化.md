---
date: "2018-01-01"
draft: false
lastmod: "2018-01-01"
publishdate: "2018-01-01"
tags:
- middleware
- redis
title: redis持久化
---
## 1. redis持久化
redis属于内存性非关系型数据库，虽为了性能急于内存实现，但本身为了满足特定场景需要的持久化的支持。redis可以通过快照持久化（RDB）或者AOF（Append Only File）来对数据进行持久化，以便恢复后重启。

## 2. 快照持久化（全量）。
redis可以通过创建快照获取存储在内容里面的数据在某个时间点上的副本，并对其进行存储或者复制到其他服务器。

### 2.1. 快照生成-手动触发
* SAVE 慎用，会阻塞redis服务，客户端所有请求命令都会被拒绝。处理效率快；
* BGSAVE redis fork子进程异步处理，效率较低。

### 2.2. 快照生成-配置策略
* 快照可以配置从时间和写入条数两个维度控制快照的生成频率,同时可以配置多个不同的递进配置，则只要匹配到一个策略就执行快照（**BGSAVE**异步执行）。 示例如下：
    ```
    # 900s内有一条数据更改则执行快照
    save 900 1

    # 300s内有10条数据更改则执行快照 
    save 300 10

    # 60s内有10000条数据更改则执行快照
    save 60 10000
    ```
* 可以配置是否使用压缩来减少存储空间使用
* 快照触发策略实现原理
    * 内部维护一组数据，数据更新数据计数器dirty（redis每做一次数据更新计数器+1）和上次执行保存操作的时间
    *reids服务周期性操作函数serverCron,默认每隔100毫秒执行一次，用来对正在运行的服务器进行维护，其中一项工作就是检查是否满足快照生成条件，如果满足则生成快照。
### 2.3. 快照的使用
快照的意义在与服务崩溃后重启数据不会大量丢失，所以快照的使用一般在服务启动时，redis自动检测并加载的，并不提供相关命令去使用。

## 3. AOF（增量）
### 3.1. 配置AOF策略
* appendfsync参数选项
    * always 每执行一条写入命令追加一次，对性能影响较大，受限于磁盘的写入速度，如果为固态硬盘次选项的设定会对其寿命严重影响，可能从几年降低到几个月（写入放大问题）。
    * everysec 每秒执行一次追加，显式的将多个命令同步到硬盘
    * no 让操作系统来决定应该何时同步

### 3.2. 重写/压缩AOF文件BGREWRITEAOF
随着redis长时间运行，AOF文件会变得庞大，占用存储空间且在重启恢复数据时耗时，所以需要通过删除冗余命令减小文件。
* 手动触发
    * BGREWRITEAOF
    
* 配置策略,两个配置同时满足
    * auto-aof-rewrite-percentage 每次重写需要超过上次重写的百分比
    * auto-aof-rewrite-min-size 重写的最小文件大小

### 3.3. SAVE & BGSAVE & BGREWRITEAOF并行性
* SAVE和BGSAVE互斥，只能有一个执行，防止产生竞争条件。
* SAVE执行期间，拒绝任何请求
* 执行BGSAVE时，如果客户端发送BGREWITEAOF，那么会被延迟到BGSAVE结束之后执行。本身两个命令的执行在操作方面没有什么冲突，只是考虑两个子进程都同时执行大量磁盘写入的问题。


### 3.4. RDB&AOF混合模式（之后）
这种持久化能够通过 AOF 重写操作创建出一个同时包含RDB数据和AOF数据的AOF文件，其中RDB数据位于AOF文件的开头，它们储存了服务器开始执行重写操作时的数据库状态： 至于那些在重写操作执行之后执行的Redis命令，则会继续以AOF格式追加到AOF文件的末尾，也即是RDB数据之后。

参数配置
* appendonly yes
* aof-use-rdb-preamble
[黄健宏 RDB-AOF 混合持久化](https://blog.huangz.me/2017/redis-rdb-aof-mixed-persistence.html)