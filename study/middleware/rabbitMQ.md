# rabbitMQ总结

[官网教程](http://www.rabbitmq.com/getstarted.html)
[官网集群](https://www.rabbitmq.com/clustering.html)
[集群搭建参考1](https://www.jianshu.com/p/6376936845ff)
[集群搭建参考2](https://juejin.im/post/5b586b125188257bcb59005e)

## 关于rabbitMQ

异步通讯中间件，实现了AMQP。异步消息能够处理的场景包括：
* 单一消费者消费消息
* 多个消费者消费消息（1个消息仅被一个消费者消费）
* 多个消费者消费同一个消息，1个消费者1个队列
* 多个消费者按照单一关注信息获取各自消费者队列
* 多个消费者按照多关注维度消费各自的消费队列
* 有返回的消费队列


## RabbitMQ需要知道的几个概念：
* 消费者，消息的接收者
* 生产者，消息的发送者
* AMQP(高级消息队列协议)
    * 信道channel
    * 交换器（四中类型，常用三种）
        * fanout，可以绑定到多个队列，可发送到多个指定的队列进行处理（广播）,不处理路由键，简单绑定即可。
        * direct，可以绑定多个队列，路由键完全匹配转发。
        * topic，不同源头的信息,路由键模式匹配
        * headers（路由规则同direct，只是过滤headers，性能较direct差）
    * 队列(可以离开交换器单独使用)
    * 绑定
## rabbitMQ的Vhost使用
* Vhost就如同一个虚拟的rabbit实例，通过rabbit的rabbitmqctl工具进行管理。使用时在连接工厂设置连接的vhost属性即可。

## 消息持久化
以下三点都做到方能做到真正的持久化
* 投递模式设置为2，持久化
* 发送到持久化的交换器
* 到达持久化的队列

## 确保信息正确投递的方式（消息收到，并转发到对应的队列，持久化等操作已完成）
* 事务模式较重（严重影响rabbit性能）
* 消息确认模式采用异步处理，更轻量级。



## 服务端及客户端的使用
*  服务端基础编码
    1. 通过连接工厂获取一个连接
    2. 通过连接得到一个信道 channel
    3. 为信道声明交换器名称和交换器类型，设置信道的反馈机制（autoAck）等等。
    4. 发布信息。
    5. 关闭信道和连接

* 客户端基础编码
    1. 通过连接工厂获取一个连接
    2. 通过连接得到一个信道 channel
    3. 绑定队列的路由规则
    4. 编码消费者逻辑并指定消费者名称
    5. 信道发布该消费者。
    6. 关闭信道和连接

## 消费者多节点（集群模式）的支持:
1.  集群支持核心思想就是同一个队列多个消费者消费，但一个消息只能有一个消费者最终消费
2. 具体操作：
    * 在各节点消费者获取消费队列时指定同一个消费队列



## 服务器管理：
* 启动管理服务rabbitmq-plugins enable rabbitmq_management(如果服务是启动的需要重启生效)
* 访问：http://hosthost:15672/  (15672是默认端口)  默认用户guest/guest


## RabbitMQ集群配置方案
* 集群目标
    * 高可用（故障恢复）
    * 并发能力
*  RabbitMQ集群特点
    * 不完全拷贝，仅拷贝如下信息：
        * 队列元数据：队列名称和它的属性；
        * 交换器元数据：交换器名称、类型和属性；
        * 绑定元数据：一张简单的表格展示了如何将消息路由到队列；
        * vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性；
        * 因此，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的。
* 集群节点分类
    * 内存节点
    * 磁盘节点
* 镜像队列