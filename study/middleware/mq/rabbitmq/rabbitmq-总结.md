# rabbitMQ总结

[官网指南](http://www.rabbitmq.com/getstarted.html)

## 一、关于rabbitMQ

异步通讯中间件，实现了AMQP。异步消息能够处理的场景包括：
* 单一消费者消费消息
* 多个消费者消费消息（1个消息仅被一个消费者消费）
* 多个消费者消费同一个消息，1个消费者1个队列(发布订阅模式，交换器类型fanout)
* 多个消费者按照单一关注信息获取各自消费者队列（交换器类型direct）
* 多个消费者按照多关注维度消费各自的消费队列（交换器类型topic）
* 有返回的消费队列(rpc)

## 二、RabbitMQ需要知道的几个概念：
* 消费者，消息的接收者
* 生产者，消息的发送者
* AMQP(高级消息队列协议)
    * 信道channel。信道是基于TCP链接的虚拟通道，所有的消息都是通过信道发送和接收的。
    * 交换器（四种类型，常用三种）
        * fanout，可以绑定到多个队列，可发送到多个指定的队列进行处理（广播）,不处理路由键，简单绑定即可。
        * direct，可以绑定多个队列，路由键完全匹配转发。
        * topic，不同源头的信息,路由键模式匹配
        * headers（路由规则同direct，只是过滤headers，性能较direct差）
    * 队列(可以离开交换器单独使用)
    * 绑定
## 三、rabbitMQ的Vhost使用
* Vhost就如同一个虚拟的rabbit实例，通过rabbit的rabbitmqctl工具进行管理。使用时在连接工厂设置连接的vhost属性即可。

## 四、消息持久化
以下三点都做到方能做到真正的持久化
* 投递模式设置为2，持久化
* 发送到持久化的交换器
* 到达持久化的队列

## 五、确保信息正确投递的方式
正确投递的含义是rabbitmq收到消息，并转发到对应的队列，持久化等操作已完成
* 事务模式较重（严重影响rabbit性能）
* 消息确认模式
    * 同步消息确认，性能稍高于事务模式
    * 批量消息确认，性能明显提升，当有个别失败，需要整个批次重发。
    * 异步消息确认，高效更轻量级，首选，只是编码稍复杂，需要自行维护发送消息id和返回的。
[参考文档](https://cloud.tencent.com/developer/article/1338402)

## 六、特别的队列
### 死信(Dead Lettering)
[官方参考文档](https://www.rabbitmq.com/dlx.html)
1. 死信队列从本质将也是一种队列，当出现如下情况时，消息进入死信队列：
    * 消息被拒绝 (basic.reject / basic.nack) 并且 reQueue=false
    * 消息过期 TTL（time to live）
    * 队列达到最大长度了

2. 死信exchanges就是普通的交换器，没有什么特别的，唯一特别指出在于其用于路由死信。
死信队列的使用：
    * 方式一：在policies中设置
    * 方式二：在声明队列时设置队列参数"x-dead-letter-exchange"用于指定死信队列交换器

    方式比较，方式二会覆盖方式一的设置。



### 惰性队列(v3.6之后)
[官方参考文档](https://www.rabbitmq.com/lazy-queues.html)
* 惰性队列时尽早的将消息内容写入磁盘，只有在消息消费的时候才读入内存。
* 惰性队列的目标：支持长更长/大打队列（百万级别的消息个数）
* 为什么引入惰性队列？当消息因为某些原因导致RAM不足时，rabbitmq会进行释放RAM,并将消息写入磁盘，这个过程比较耗时，且会中断消息处理。惰性队列会尽可能早的将消息写入磁盘，保持RAM空间的稳定。


## 七、应用编码步骤
*  服务端基础编码
    1. 通过连接工厂获取一个连接，该链接位重量级的，TCP链接，一般链接的两端只需要一个链接（即按照应用和中间件两个纬度来创建）
    2. 通过连接得到一个信道 channel
    3. 为信道声明交换器名称和交换器类型，设置信道的反馈机制（autoAck）等等。
    4. 发布信息。
    5. 关闭信道和连接

* 客户端基础编码
    1. 通过连接工厂获取一个连接
    2. 通过连接得到一个信道 channel
    3. 绑定队列的路由规则
    4. 编码消费者逻辑并指定消费者名称
    5. 信道发布该消费者。
    6. 关闭信道和连接

## 八、RabbitMQ集群配置方案
* 集群目标
    * 高可用（故障恢复）
        * 方式一：通过持久化文件恢复
        * 方式二：使用镜像队列
    * 并发能力（增加集群节点横向扩展）
*  RabbitMQ集群特点
    * 每个集群节点都有一份元数据拷贝，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的。
    * 当客户端连接的节点为非队列属主节点时，该节点将队列转发至属主节点。
* 集群节点
    * 集群节点由集群名唯一区别，集群节点由两部分组成，前缀（通常为rabbit）和主机名，如rabbit@localhost
    * 集群节点分类
        * 内存节点，节点中rabbitmq集群元数据仅存储在ram中。
        * 磁盘节点，节点中rabbitmq集群元数据存储在磁盘中。
* 镜像队列
    * 镜像队列可以理解为节点的备，当某节点故障后，该节点上队列的镜像队列将启用。镜像队列需要在客户断进行设置，可以设置所有的节点作为副本或者指定节点。

* 消费者端多节点（集群模式）的支持:
    * 集群支持核心思想就是同一个队列多个消费者消费，但一个消息只能有一个消费者最终消费
    * 具体操作：在各节点消费者获取消费队列时指定同一个消费队列

## 九、Rabbitmq设计方案及开发注意事项
* 消息丢失
* 重复消费
* 节点奔溃处理
    * 监控