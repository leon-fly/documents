---
date: "2018-01-01"
draft: false
lastmod: "2018-01-01"
publishdate: "2018-01-01"
tags:
- middleware
- mq
- rabbitmq
title: rabbitmq-总结
---

## 一、关于rabbitMQ

异步通讯中间件，实现了AMQP。异步消息能够处理的场景包括：
* 单一消费者消费消息
* 多个消费者消费消息（1个消息仅被一个消费者消费）
* 多个消费者消费同一个消息，1个消费者1个队列(发布订阅模式，交换器类型fanout)
* 多个消费者按照单一关注信息获取各自消费者队列（交换器类型direct）
* 多个消费者按照多关注维度消费各自的消费队列（交换器类型topic）
* 有返回的消费队列(rpc)

## 二、RabbitMQ需要知道的几个概念：
* 消费者，消息的接收者
* 生产者，消息的发送者
* AMQP(高级消息队列协议)
    * 信道channel。信道是基于TCP链接的虚拟通道，所有的消息都是通过信道发送和接收的。
    * 交换器（四种类型，常用三种）
        * fanout，可以绑定到多个队列，可发送到多个指定的队列进行处理（广播）,不处理路由键，简单绑定即可。
        * direct，可以绑定多个队列，路由键完全匹配转发。
        * topic，不同源头的信息,路由键模式匹配
        * headers（路由规则同direct，只是过滤headers，性能较direct差）
    * 队列(可以离开交换器单独使用)
    * 绑定
## 三、rabbitMQ的Vhost使用
* Vhost就如同一个虚拟的rabbit实例，通过rabbit的rabbitmqctl工具进行管理。使用时在连接工厂设置连接的vhost属性即可。

## 四、消息持久化
以下三点都做到方能做到真正的持久化
* 投递模式设置为2，持久化
* 发送到持久化的交换器
* 到达持久化的队列

## 五、确保信息正确投递的方式
正确投递的含义是rabbitmq收到消息，并转发到对应的队列，持久化等操作已完成
* 事务模式较重（严重影响rabbit性能）
* 生产者消息确认模式
    * 同步消息确认，性能稍高于事务模式
    * 批量消息确认，性能明显提升，当有个别失败，需要整个批次重发。
    * 异步消息确认，高效更轻量级，首选，只是编码稍复杂，需要自行维护发送消息id和返回的。
* 消费者消息确认模式
    
[参考文档](https://cloud.tencent.com/developer/article/1338402)

## 六、特别的队列
### 死信(Dead Lettering)
[官方参考文档](https://www.rabbitmq.com/dlx.html)
1. 死信队列从本质将也是一种队列，当出现如下情况时，消息进入死信队列：
    * 消息被拒绝 (basic.reject / basic.nack) 并且 reQueue=false
    * 消息过期 TTL（time to live）
    * 队列达到最大长度了

2. 死信exchanges就是普通的交换器，没有什么特别的，唯一特别指出在于其用于路由死信。
死信队列的使用：
    * 方式一：在policies中设置
    * 方式二：在声明队列时设置队列参数"x-dead-letter-exchange"用于指定死信队列交换器

    方式比较，方式二会覆盖方式一的设置。



### 惰性队列(v3.6之后)
[官方参考文档](https://www.rabbitmq.com/lazy-queues.html)
* 惰性队列是尽早的将消息内容写入磁盘，只有在消息消费的时候才读入内存。
* 惰性队列的目标：支持更长/大的队列（百万级别的消息个数）
* 为什么引入惰性队列？当消息因为某些原因导致RAM不足时，rabbitmq会进行释放RAM,并将消息写入磁盘，这个过程比较耗时，且会中断消息处理。惰性队列会尽可能早的将消息写入磁盘，保持RAM空间的稳定。


## 七、应用编码步骤
*  服务端基础编码
    1. 通过连接工厂获取一个连接，该链接位重量级的，TCP链接，一般链接的两端只需要一个链接（即按照应用和中间件两个纬度来创建）
    2. 通过连接得到一个信道 channel
    3. 为信道声明交换器名称和交换器类型，设置信道的反馈机制（autoAck）等等。
    4. 发布信息。
    5. 关闭信道和连接

* 客户端基础编码
    1. 通过连接工厂获取一个连接
    2. 通过连接得到一个信道 channel
    3. 绑定队列的路由规则
    4. 编码消费者逻辑并指定消费者名称
    5. 信道发布该消费者。
    6. 关闭信道和连接

## 八、RabbitMQ集群配置方案
* 集群目标
    * 高可用（故障恢复）
        * 方式一：通过持久化文件恢复
        * 方式二：使用镜像队列
    * 并发能力（增加集群节点横向扩展）
*  RabbitMQ集群特点
    * 每个集群节点都有一份元数据拷贝，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的。
    * 当客户端连接的节点为非队列属主节点时，该节点将队列转发至属主节点。
    * 当新加入一个集群节点时，其他节点上的镜像队列数据不会主动同步到新节点（可以用过命令完成同步 参照rabbitmqctl cancel_sync_queue）
    * 集群节点故障后，镜像队列的主节点会发生转移，该节点中的非镜像队列将不可用。
    * 当集群节点全部停掉之后，最后停掉的节点可以独立启动而不需要与其他节点通信，而其他节点不可以。其他节点只能等最后停掉的那台主机启动后才能启动，这个等待窗口可以通过如下参数进行配置
        ```
        # wait for 60 seconds instead of 30
        mnesia_table_loading_retry_timeout = 60000

        # retry 15 times instead of 10
        mnesia_table_loading_retry_limit = 15
        ```
* 集群节点
    * 集群节点由集群名唯一区别，集群节点由两部分组成，前缀（通常为rabbit）和主机名，如rabbit@localhost
    * 集群节点分类
        * 内存节点（RAM），节点中rabbitmq集群元数据仅存储在ram中。
        * 磁盘节点（DISK/DISC），节点中rabbitmq集群元数据存储在磁盘中。集群一般节点都设为磁盘节点,如果考虑特殊原因需要使用内存节点，那么至少要有一个磁盘节点，用以集群重启后元数据的获取。
* 镜像队列
    * 镜像队列可以理解为节点的备，当某节点故障后，该节点上队列的镜像队列将启用。镜像队列需要在客户端进行设置，可以设置所有的节点或者指定节点作为副本，或者指定副本个数等策略。
    * 原理
        * 可以将镜像队列视为拥有一个隐藏的fanout交换器，它指示着信道将消息分发到队列的从拷贝上，使用确认模式时确认机制将扩展到队列的从拷贝。
    * 节点故障表现(所有节点同步状态下)
        * 当故障发生在从拷贝时，对生产者和消费者客户端都不会有影响
        * 当故障发生在主拷贝，从拷贝变成了主拷贝时
            * 当故障发生在生产者消息发送之后，对于生产者客户端来讲发送方确认消息永远不会到达，这一般不会有什么影响，重新发送消息即可。
            * 对于消费者客户端来讲：
                * 如果连接的是故障节点，客户端通过重新选取集群节点可以重新消费队列消息，一般也不会有什么影响。
                * 如果连接的是非故障节点，依然能够进行消费。
            * 已经在主节点消费了但未确认对消息会重新进入队列，需要考虑重复消费，如幂等支持。

* 消费者端多节点（集群模式）的支持:
    * 集群支持核心思想就是同一个队列多个消费者消费，但一个消息只能有一个消费者最终消费
    * 具体操作：在各节点消费者获取消费队列时指定同一个消费队列

## 九、Rabbitmq设计方案及开发注意事项
* 消息丢失
* 重复消费
* 节点奔溃处理
    * 客户端重连
    * 监控

## 参考文档
👉  [官网指南](http://www.rabbitmq.com/getstarted.html)